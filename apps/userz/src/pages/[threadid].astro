---
type Thread = {genid:string; text:string}[]
import { neon } from '@neondatabase/serverless';
import Layout from "../components/Layout.astro";
import {gql} from "../components/helpers/gql";
import {uniq} from 'lodash'

const sql = neon(import.meta.env.DB_URL1 || process.env.DB_URL1);
const sql2 = neon(import.meta.env.DB_URL2 || process.env.DB_URL2);

const { threadid } = Astro.params as { threadid: string };

async function extractUniqueHashtags(inputString: string): Promise<{hashtag:string,count:number}[]> {
  const hashtagRegex = /#(\w+)/g;
  const hashtags = inputString.match(hashtagRegex);
  if (!hashtags) return [];
  const uniqueHashtags = Array.from(new Set(hashtags.map(tag =>  ({hashtag:tag.slice(1),count:10}))));
  return uniqueHashtags;
} 
function removeHashtags(inputString: string): string {
  const hashtagRegex = /#\w+/g;
  const stringWithoutHashtags = inputString.replace(hashtagRegex, '');
  return stringWithoutHashtags;
}


const respOne  =  sql`select id,text,image from questions where genid = ${threadid} and type = 'q'`
const respOneThread  =  sql`select text,genid from questions where genid = ${threadid} and type = 'a'`
const respTwo =   sql2`
 SELECT genid
FROM questions
ORDER BY embed <->
(SELECT embed FROM questions WHERE genid = ${threadid} LIMIT 1)
LIMIT 10 OFFSET 1;
`;

const prom = await Promise.all([respOne, respTwo,respOneThread]).then((values) => {
  return({resp:values[0][0],simResultsOne:values[1],threadx:values[2]})
}) as { resp:{text:string, image?: string,id:number},threadx:Thread,q:Thread ,simResultsOne:{genid:string}[]};
const {simResultsOne,resp,threadx} = prom
const simResults = simResultsOne.map(x => x.genid)

 
 const rest=  threadx;
 const question= resp.text;
 const image = resp.image;
 console.log(image);
 const formatter = (text:string) => {
	 let resp = removeHashtags(text).replaceAll('@username,','').replaceAll('@username','').split('\n')
	 return(resp)
 }

 if(!threadx[0]) {
	  return Astro.redirect('/404')
  } 
  
 const extended  = await gql('specificids',{_in:simResults})  as {questions:{genid:string,text:string}[],answers:{genid:string,text:string}[]}

 const thread = extended.questions.map((x,i) => ({
   q:{text:x.text,genid:x.genid},
   a:extended.answers[i]?.text || ''
 }))
  
 
 
 const flat = await extractUniqueHashtags(uniq(thread.flatMap(x => x.a)).join(' '))
 const tagz = await gql('specifictags',{_in:flat.flatMap(x => x.hashtag)}) as {qtags:{count:number,hashtag:string}[]}
 const tagzfiltered = tagz.qtags.filter(x => x.count >= 10).sort((a,z) => {return(z.count -a.count)} ).slice(0,30)
 
 
 
---
<Layout title={question} description={''} logo={"inner"}  tags={tagzfiltered}>	 
    <article class="prose prose-invert prose-headings:underline mx-auto">
       <h1 class="text-white font-medium">{question}</h1>
       {image && image !== 'none' && (<div>
         <img src={"https://cdn.userz.net/"+resp.id+".jpg"} class="rounded-md">
         </div>)}
      {  rest.map(({text})  =>  {
        return(<div class="text-white text-xl font-light">{formatter(text).map(x=> (<p>{x}</p>))  }</div>)}
      )}
       {extended.questions[0] && <h2 class="text-gray-100 font-bold">Extended FAQ</h2> }
          {thread.map((q) => ( <div class="space-x-3">
                 <a class="flex items-center" href={'/'+q.q.genid}>
                    <h2 class="pl-2 text-gray-200 underline"> {q.q.text.replace('?','')}</h2>
                 </a>
         { formatter(q.a).map(x => (<p>{x}</p>))}
             </div>))}
       
     </article>
	
 
 
</Layout>